defmodule Asa.MockMotorDriver do
  alias Asa.StepperMotorMovements, as: SMM
  def init(%{enable: _, step: _, dir: _} = pins, spr) when spr > 0 do
    %Asa.MotorState{pins: pins, step: 0, enabled: false, direction: 0, spr: spr, sleep_int: 100}
    |> start
  end

  defp start(%Asa.MotorState{} = state), do: {:ok, spawn(fn -> loop state end)}

  def loop(%Asa.MotorState{} = state) do
    IO.puts "entered loop"
    receive do
      {:goto, newStep} -> state = goto(state, newStep)
      _ -> handUnknown(state)
    end
    loop(state)
  end

  defp goto(state,newStep) do 
    IO.puts "Goto rec. #{newStep}"
    startTime = getMilliseconds()
    state = _handleGoto(state,newStep)
    endTime = getMilliseconds()
    IO.puts "New step #{state.step}, took #{endTime - startTime}ms"
    state
  end

  def getMilliseconds() do
    {_mega,sec,micro} = :erlang.now()
    (sec)*1_000_000+micro
  end
  defp handUnknown(state) do 
    IO.puts "unsupported message received"
    state
  end

  defp _handleGoto(%Asa.MotorState{enabled: mtrEn} = state, newStep) when mtrEn == false do
    IO.puts "enabling motor"
    #enable motor
    :timer.sleep(state.sleep_int)
    state = %{state| enabled: true}
    _handleGoto(state, newStep)
  end

  defp _handleGoto(state, newStep) do
    steps = SMM.getSteps(state,newStep)
    dir = SMM.getDirection(state,newStep,steps)

    _move(state,dir,steps)
  end

  defp _move(state, _dir, 0), do: state
  defp _move(%{direction: sDir} = state, dir, steps) when sDir != dir do
    #set direction pin
    :timer.sleep(state.sleep_int)
    %{state| direction: dir}
    |> _move dir, steps
  end
  defp _move(state, dir, steps) do
    case _messagesReceived() do
      false -> _doMove(state,dir) |> _move(dir,steps-1)
      true -> _move(state,0,0)
    end
  end

  defp _doMove(state, dir) do
    newStep = SMM.getNextStep(state,dir)
    #set step pin high
    :timer.sleep(state.sleep_int)
    #set step pin low
    :timer.sleep(state.sleep_int)
    %{state|step: newStep}
  end

  def _messagesReceived() do
    #{:message_queue_len, numMessages} = Process.info(self(), :message_queue_len)
    numMessages = 0
    #anymessages received while moving will cause driver to stop
    #immediately and process message. Driver should only ever be sent
    #goto and calibrate messages

    if numMessages > 0 do
      true
    else
      false
    end
  end

  #TODO: Should calibration cannot be interupted,
  #  calibrate logic will be similar to move
end
