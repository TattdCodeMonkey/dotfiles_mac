// From: http://www.mathworks.com/matlabcentral/files/8607/vdist.m

            /*
             function varargout = vdist(lat1, lon1, lat2, lon2)
            % VDIST - Using the WGS-84 Earth ellipsoid, compute the distance between
            %         two points within a few millimeters of accuracy, compute forward
            %         azimuth, and compute backward azimuth, all using a vectorized
            %         version of Vincenty's algorithm.
            %
            % s = vdist(lat1, lon1, lat2, lon2)
            % [s, a12] = vdist(lat1, lon1, lat2, lon2)
            % [s, a12, a21] = vdist(lat1, lon1, lat2, lon2)
            %
            % s = distance in meters (inputs may be scalars, vectors, or matrices)
            % a12 = azimuth in degrees from first point to second point (forward)
            % a21 = azimuth in degrees from second point to first point (backward)
            %       (Azimuths are in degrees clockwise from north.)
            % lat1 = GEODETIC latitude of first point (degrees)
            % lon1 = longitude of first point (degrees)
            % lat2, lon2 = second point (degrees)
            %
            %  Original algorithm source:
            %  T. Vincenty, "Direct and Inverse Solutions of Geodesics on the Ellipsoid
            %  with Application of Nested Equations", Survey Review, vol. 23, no. 176,
            %  April 1975, pp 88-93.
            %  Available at: http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf
            %
            % Notes: (1) lat1, lon1, lat2, lon2 can be any (identical) size/shape. Outputs
            %            will have the same size and shape.
            %        (2) Error correcting code, convergence failure traps, antipodal
            %            corrections, polar error corrections, WGS84 ellipsoid
            %            parameters, testing, and comments: Michael Kleder, 2004.
            %        (3) Azimuth implementation (including quadrant abiguity
            %            resolution) and code vectorization, Michael Kleder, Sep 2005.
            %        (4) Vectorization is convergence sensitive; that is, quantities
            %            which have already converged to within tolerance are not
            %            recomputed during subsequent iterations (while other
            %            quantities are still converging).
            %        (5) Vincenty describes his distance algorithm as precise to within
            %            0.01 millimeters, subject to the ellipsoidal model.
            %        (6) For distance calculations, essentially antipodal points are
            %            treated as exactly antipodal, potentially reducing accuracy
            %            slightly.
            %        (7) Distance failures for points exactly at the poles are
            %            eliminated by moving the points by 0.6 millimeters.
            %        (8) The Vincenty distance algorithm was transcribed verbatim by
            %            Peter Cederholm, August 12, 2003. It was modified and
            %            translated to English by Michael Kleder.
            %            Mr. Cederholm's website is http://www.plan.aau.dk/~pce/
            %        (9) Distances agree with the Mapping Toolbox, version 2.2 (R14SP3)
            %            with a max relative difference of about 5e-9, except when the
            %            two points are nearly antipodal, and except when one point is
            %            near the equator and the two longitudes are nearly 180 degrees
            %            apart. This function (vdist) is more accurate in such cases.
            %            For example, notice this difference (as of this writing):
            %            >>vdist(0.2, 305, 15, 125)
            %            18322827.0131551
            %            >>distance(0.2, 305, 15, 125, [6378137 0.08181919])
            %            0
            %       (10) Azimuths FROM the north pole (either forward starting at the
            %            north pole or backward when ending at the north pole) are set
            %            to 180 degrees by convention. Azimuths FROM the south pole are
            %            set to 0 degrees by convention.
            %       (11) Azimuths agree with the Mapping Toolbox, version 2.2 (R14SP3)
            %            to within about a hundred-thousandth of a degree, except when
            %            traversing to or from a pole, where the convention for this
            %            function is described in (10), and except in the cases noted
            %            above in (9).
            %       (12) No warranties; use at your own risk.

            % reshape inputs
            keepsize = size(lat1);
            lat1=lat1(:);
            lon1=lon1(:);
            lat2=lat2(:);
            lon2=lon2(:);
            % Input check:
            if any(abs(lat1)>90 | abs(lat2)>90)
                error('Input latitudes must be between -90 and 90 degrees, inclusive.')
            end
            % Supply WGS84 earth ellipsoid axis lengths in meters:
            a = 6378137; % definitionally
            b = 6356752.31424518; % computed from WGS84 earth flattening coefficient
            % preserve true input latitudes:
            lat1tr = lat1;
            lat2tr = lat2;
            % convert inputs in degrees to radians:
            lat1 = lat1 * 0.0174532925199433;
            lon1 = lon1 * 0.0174532925199433;
            lat2 = lat2 * 0.0174532925199433;
            lon2 = lon2 * 0.0174532925199433;
            % correct for errors at exact poles by adjusting 0.6 millimeters:
            kidx = abs(pi/2-abs(lat1)) < 1e-10;
            if any(kidx);
                lat1(kidx) = sign(lat1(kidx))*(pi/2-(1e-10));
            end
            kidx = abs(pi/2-abs(lat2)) < 1e-10;
            if any(kidx)
                lat2(kidx) = sign(lat2(kidx))*(pi/2-(1e-10));
            end
            f = (a-b)/a;
            U1 = atan((1-f)*tan(lat1));
            U2 = atan((1-f)*tan(lat2));
            lon1 = mod(lon1, 2*pi);
            lon2 = mod(lon2, 2*pi);
            L = abs(lon2-lon1);
            kidx = L > pi;
            if any(kidx)
                L(kidx) = 2*pi - L(kidx);
            end
            lambda = L;
            lambdaold = 0*lat1;
            itercount = 0;
            notdone = logical(1+0*lat1);
            alpha = 0*lat1;
            sigma = 0*lat1;
            cos2sigmam = 0*lat1;
            C = 0*lat1;
            warninggiven = logical(0);
            while any(notdone)  % force at least one execution
                %disp(['lambda(21752) = ' num2str(lambda(21752), 20)]);
                itercount = itercount+1;
                if itercount > 50
                    if ~warninggiven
                        warning(['Essentially antipodal points encountered. ' ...
                            'Precision may be reduced slightly.']);
                    end
                    lambda(notdone) = pi;
                    break
                end
                lambdaold(notdone) = lambda(notdone);
                sinsigma(notdone) = sqrt((cos(U2(notdone)).*sin(lambda(notdone)))...
                    .^2+(cos(U1(notdone)).*sin(U2(notdone))-sin(U1(notdone)).*...
                    cos(U2(notdone)).*cos(lambda(notdone))).^2);
                cossigma(notdone) = sin(U1(notdone)).*sin(U2(notdone))+...
                    cos(U1(notdone)).*cos(U2(notdone)).*cos(lambda(notdone));
                % eliminate rare imaginary portions at limit of numerical precision:
                sinsigma(notdone)=real(sinsigma(notdone));
                cossigma(notdone)=real(cossigma(notdone));
                sigma(notdone) = atan2(sinsigma(notdone), cossigma(notdone));
                alpha(notdone) = asin(cos(U1(notdone)).*cos(U2(notdone)).*...
                    sin(lambda(notdone))./sin(sigma(notdone)));
                cos2sigmam(notdone) = cos(sigma(notdone))-2*sin(U1(notdone)).*...
                    sin(U2(notdone))./cos(alpha(notdone)).^2;
                C(notdone) = f/16*cos(alpha(notdone)).^2.*(4+f*(4-3*...
                    cos(alpha(notdone)).^2));
                lambda(notdone) = L(notdone)+(1-C(notdone)).*f.*sin(alpha(notdone))...
                    .*(sigma(notdone)+C(notdone).*sin(sigma(notdone)).*...
                    (cos2sigmam(notdone)+C(notdone).*cos(sigma(notdone)).*...
                    (-1+2.*cos2sigmam(notdone).^2)));
                %disp(['then, lambda(21752) = ' num2str(lambda(21752), 20)]);
                % correct for convergence failure in the case of essentially antipodal
                % points
                if any(lambda(notdone) > pi)
                    warning(['Essentially antipodal points encountered. ' ...
                        'Precision may be reduced slightly.']);
                    warninggiven = logical(1);
                    lambdaold(lambda>pi) = pi;
                    lambda(lambda>pi) = pi;
                end
                notdone = abs(lambda-lambdaold) > 1e-12;
            end
            u2 = cos(alpha).^2.*(a^2-b^2)/b^2;
            A = 1+u2./16384.*(4096+u2.*(-768+u2.*(320-175.*u2)));
            B = u2./1024.*(256+u2.*(-128+u2.*(74-47.*u2)));
            deltasigma = B.*sin(sigma).*(cos2sigmam+B./4.*(cos(sigma).*(-1+2.*...
                cos2sigmam.^2)-B./6.*cos2sigmam.*(-3+4.*sin(sigma).^2).*(-3+4*...
                cos2sigmam.^2)));
            varargout{1} = reshape(b.*A.*(sigma-deltasigma), keepsize);
            if nargout > 1
                % From point #1 to point #2
                % correct sign of lambda for azimuth calcs:
                lambda = abs(lambda);
                kidx=sign(sin(lon2-lon1)) .* sign(sin(lambda)) < 0;
                lambda(kidx) = -lambda(kidx);
                numer = cos(U2).*sin(lambda);
                denom = cos(U1).*sin(U2)-sin(U1).*cos(U2).*cos(lambda);
                a12 = atan2(numer, denom);
                kidx = a12<0;
                a12(kidx)=a12(kidx)+2*pi;
                % from poles:
                a12(lat1tr <= -90) = 0;
                a12(lat1tr >= 90 ) = pi;
                varargout{2} = reshape(a12 * 57.2957795130823, keepsize); % to degrees
            end
            if nargout > 2
                a21=NaN*lat1;
                % From point #2 to point #1
                % correct sign of lambda for azimuth calcs:
                lambda = abs(lambda);
                kidx=sign(sin(lon1-lon2)) .* sign(sin(lambda)) < 0;
                lambda(kidx)=-lambda(kidx);
                numer = cos(U1).*sin(lambda);
                denom = sin(U1).*cos(U2)-cos(U1).*sin(U2).*cos(lambda);
                a21 = atan2(numer, denom);
                kidx=a21<0;
                a21(kidx)= a21(kidx)+2*pi;
                % backwards from poles:
                a21(lat2tr >= 90) = pi;
                a21(lat2tr <= -90) = 0;
                varargout{3} = reshape(a21 * 57.2957795130823, keepsize); % to degrees
            end
            return

             *
             *
             */

            // If positions are equivalent, return zero
            if (Equals(destination))
                return Azimuth.Empty;

            #region Newer code

            double goodLambda = 0;
            //double goodAlpha = 0;
            //double goodSigma = 0;
            //double goodCos2SigmaM = 0;

            //            % reshape inputs
            //keepsize = size(lat1);
            //lat1=lat1(:);
            //lon1=lon1(:);
            //lat2=lat2(:);
            //lon2=lon2(:);

            // ?

            //% Input check:
            //if any(abs(lat1)>90 | abs(lat2)>90)
            //    error('Input latitudes must be between -90 and 90 degrees, inclusive.')
            //end

            // The -90 to 90 check is handled by Normalize

            //% Supply WGS84 earth ellipsoid axis lengths in meters:
            //a = 6378137; % definitionally
            //b = 6356752.31424518; % computed from WGS84 earth flattening coefficient

            //double a = ellipsoid.EquatorialRadiusMeters;
            //double b = ellipsoid.PolarRadiusMeters;

            //% preserve true input latitudes:
            //lat1tr = lat1;
            //lat2tr = lat2;

            double lat1Tr = _latitude.DecimalDegrees;

            /* FxCop says that "lat2tr" is only assigned to, but never used.
             *

            double lat2tr = destination.Latitude.DecimalDegrees;

             */

            //% convert inputs in degrees to radians:
            //lat1 = lat1 * 0.0174532925199433;
            //lon1 = lon1 * 0.0174532925199433;
            //lat2 = lat2 * 0.0174532925199433;
            //lon2 = lon2 * 0.0174532925199433;

            // Convert inputs into radians
            double lat1 = Latitude.Normalize().ToRadians().Value;
            double lon1 = Longitude.Normalize().ToRadians().Value;
            double lat2 = destination.Latitude.Normalize().ToRadians().Value;
            double lon2 = destination.Longitude.Normalize().ToRadians().Value;

            //% correct for errors at exact poles by adjusting 0.6 millimeters:
            //kidx = abs(pi/2-abs(lat1)) < 1e-10;
            //if any(kidx);
            //    lat1(kidx) = sign(lat1(kidx))*(pi/2-(1e-10));
            //end

            // Correct for errors at exact poles by adjusting 0.6mm
            if (Math.Abs(Math.PI * 0.5 - Math.Abs(lat1)) < 1E-10)
            {
                lat1 = Math.Sign(lat1) * (Math.PI * 0.5 - 1E-10);
            }

            //kidx = abs(pi/2-abs(lat2)) < 1e-10;
            //if any(kidx)
            //    lat2(kidx) = sign(lat2(kidx))*(pi/2-(1e-10));
            //end

            if (Math.Abs(Math.PI * 0.5 - Math.Abs(lat2)) < 1E-10)
            {
                lat2 = Math.Sign(lat2) * (Math.PI * 0.5 - 1E-10);
            }

            //f = (a-b)/a;

            double f = ellipsoid.Flattening;

            //U1 = atan((1-f)*tan(lat1));

            double u1 = Math.Atan((1 - f) * Math.Tan(lat1));

            //U2 = atan((1-f)*tan(lat2));

            double u2 = Math.Atan((1 - f) * Math.Tan(lat2));

            //lon1 = mod(lon1, 2*pi);

            lon1 = lon1 % (2 * Math.PI);

            //lon2 = mod(lon2, 2*pi);

            lon2 = lon2 % (2 * Math.PI);

            //L = abs(lon2-lon1);

            double l = Math.Abs(lon2 - lon1);

            //kidx = L > pi;
            //if any(kidx)
            //    L(kidx) = 2*pi - L(kidx);
            //end

            if (l > Math.PI)
            {
                l = 2.0 * Math.PI - l;
            }

            //lambda = L;

            double lambda = l;

            //lambdaold = 0*lat1;

            //itercount = 0;

            int itercount = 0;

            //notdone = logical(1+0*lat1);

            bool notdone = true;

            //alpha = 0*lat1;

            //sigma = 0*lat1;

            //cos2sigmam = 0*lat1;

            //C = 0*lat1;

            //warninggiven = logical(0);

            //bool warninggiven = false;

            //while any(notdone)  % force at least one execution

            while (notdone)
            {
                //    %disp(['lambda(21752) = ' num2str(lambda(21752), 20)]);
                //    itercount = itercount+1;

                itercount++;

                //    if itercount > 50

                if (itercount > 50)
                {
                    //        if ~warninggiven

                    //if (!warninggiven)
                    //{
                    //    //            warning(['Essentially antipodal points encountered. ' ...
                    //    //                'Precision may be reduced slightly.']);

                    //    warninggiven = true;
                    //    throw new WarningException("Distance calculation accuracy may be reduced because the two endpoints are antipodal.");
                    //}

                    //        end
                    //        lambda(notdone) = pi;

                    //lambda = Math.PI;

                    //        break

                    break;

                    //    end
                }

                //    lambdaold(notdone) = lambda(notdone);

                double lambdaold = lambda;

                //    sinsigma(notdone) = sqrt((cos(U2(notdone)).*sin(lambda(notdone)))...
                //        .^2+(cos(U1(notdone)).*sin(U2(notdone))-sin(U1(notdone)).*...
                //        cos(U2(notdone)).*cos(lambda(notdone))).^2);

                double sinsigma = Math.Sqrt(Math.Pow((Math.Cos(u2) * Math.Sin(lambda)), 2)
                         + Math.Pow((Math.Cos(u1) * Math.Sin(u2) - Math.Sin(u1) *
                        Math.Cos(u2) * Math.Cos(lambda)), 2));

                //    cossigma(notdone) = sin(U1(notdone)).*sin(U2(notdone))+...
                //        cos(U1(notdone)).*cos(U2(notdone)).*cos(lambda(notdone));

                double cossigma = Math.Sin(u1) * Math.Sin(u2) +
                    Math.Cos(u1) * Math.Cos(u2) * Math.Cos(lambda);

                //    % eliminate rare imaginary portions at limit of numerical precision:
                //    sinsigma(notdone)=real(sinsigma(notdone));
                //    cossigma(notdone)=real(cossigma(notdone));

                // Eliminate rare imaginary portions at limit of numerical precision:
                // ?

                //    sigma(notdone) = atan2(sinsigma(notdone), cossigma(notdone));

                double sigma = Math.Atan2(sinsigma, cossigma);

                //    alpha(notdone) = asin(cos(U1(notdone)).*cos(U2(notdone)).*...
                //        sin(lambda(notdone))./sin(sigma(notdone)));

                double alpha = Math.Asin(Math.Cos(u1) * Math.Cos(u2) *
                                         Math.Sin(lambda) / Math.Sin(sigma));

                //    cos2sigmam(notdone) = cos(sigma(notdone))-2*sin(U1(notdone)).*...
                //        sin(U2(notdone))./cos(alpha(notdone)).^2;

                double cos2SigmaM = Math.Cos(sigma) - 2.0 * Math.Sin(u1) *
                                    Math.Sin(u2) / Math.Pow(Math.Cos(alpha), 2);

                //    C(notdone) = f/16*cos(alpha(notdone)).^2.*(4+f*(4-3*...
                //        cos(alpha(notdone)).^2));

                double c = f / 16 * Math.Pow(Math.Cos(alpha), 2) * (4 + f * (4 - 3 *
                                                                             Math.Pow(Math.Cos(alpha), 2)));

                //    lambda(notdone) = L(notdone)+(1-C(notdone)).*f.*sin(alpha(notdone))...
                //        .*(sigma(notdone)+C(notdone).*sin(sigma(notdone)).*...
                //        (cos2sigmam(notdone)+C(notdone).*cos(sigma(notdone)).*...
                //        (-1+2.*cos2sigmam(notdone).^2)));

                lambda = l + (1 - c) * f * Math.Sin(alpha)
                            * (sigma + c * Math.Sin(sigma) *
                            (cos2SigmaM + c * Math.Cos(sigma) *
                            (-1 + 2 * Math.Pow(cos2SigmaM, 2))));

                //    %disp(['then, lambda(21752) = ' num2str(lambda(21752), 20)]);
                //    % correct for convergence failure in the case of essentially antipodal
                //    % points

                // Correct for convergence failure in the case of essentially antipodal points

                //    if any(lambda(notdone) > pi)

                if (lambda > Math.PI)
                {
                    //        if ~warninggiven

                    //if (!warninggiven)
                    //{
                    //    //            warning(['Essentially antipodal points encountered. ' ...
                    //    //                'Precision may be reduced slightly.']);

                    //    warninggiven = true;
                    //    throw new WarningException("Distance calculation accuracy may be reduced because the two endpoints are antipodal.");
                    //}

                    //        end

                    //        lambdaold(lambda>pi) = pi;

                    lambdaold = Math.PI;

                    //        lambda(lambda>pi) = pi;

                    lambda = Math.PI;

                    //    end
                }

                //    notdone = abs(lambda-lambdaold) > 1e-12;

                notdone = Math.Abs(lambda - lambdaold) > TARGET_ACCURACY;

                //end

                // notice: In some cases "alpha" would return a "NaN".  If values are healthy,
                // remember them so we get a good distance calc.
                if (!double.IsNaN(alpha))
                {
                    goodLambda = lambda;
                    //goodAlpha = alpha;
                    //goodSigma = sigma;
                    //goodCos2SigmaM = cos2sigmam;
                }
            }

            //u2 = cos(alpha).^2.*(a^2-b^2)/b^2;
            // This was never used
            // double u2 = Math.Pow(Math.Cos(goodAlpha), 2) * (Math.Pow(a, 2) - Math.Pow(b, 2)) / Math.Pow(b, 2);

            //A = 1+u2./16384.*(4096+u2.*(-768+u2.*(320-175.*u2)));

            // The variable A here was never used, so i commented this out.  (Ted)
            //double A = 1 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));

            //B = u2./1024.*(256+u2.*(-128+u2.*(74-47.*u2)));

            // This was never used (TD)
            //double B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));

            //deltasigma = B.*sin(sigma).*(cos2sigmam+B./4.*(cos(sigma).*(-1+2.*...
            //    cos2sigmam.^2)-B./6.*cos2sigmam.*(-3+4.*sin(sigma).^2).*(-3+4*...
            //    cos2sigmam.^2)));

            // This was never used (TD)
            //double deltasigma = B * Math.Sin(goodSigma) * (goodCos2SigmaM + B / 4 * (Math.Cos(goodSigma) * (-1 + 2 *
            //    Math.Pow(goodCos2SigmaM, 2)) - B / 6 * goodCos2SigmaM * (-3 + 4 * Math.Pow(Math.Sin(goodSigma), 2)) * (-3 + 4 *
            //    Math.Pow(goodCos2SigmaM, 2))));

            //varargout{1} = reshape(b.*A.*(sigma-deltasigma), keepsize);

            /* FxCop says that this variable "double s" is only assigned to, but never used.
             *

            double s = b * A * (goodsigma - deltasigma);

             */

            // Return the Distance in meters
            //return new Distance(s, DistanceUnit.Meters).ToLocalUnitType();

            //if nargout > 1
            //    % From point #1 to point #2
            //    % correct sign of lambda for azimuth calcs:

            //    lambda = abs(lambda);

            goodLambda = Math.Abs(goodLambda);

            //    kidx=sign(sin(lon2-lon1)) .* sign(sin(lambda)) < 0;

            bool kidx = Math.Sign(Math.Sin(lon2 - lon1)) * Math.Sign(Math.Sin(goodLambda)) < 0;

            //    lambda(kidx) = -lambda(kidx);

            if (kidx)
                goodLambda = -goodLambda;

            //    numer = cos(U2).*sin(lambda);

            double numer = Math.Cos(u2) * Math.Sin(goodLambda);

            //    denom = cos(U1).*sin(U2)-sin(U1).*cos(U2).*cos(lambda);

            double denom = Math.Cos(u1) * Math.Sin(u2) - Math.Sin(u1) * Math.Cos(u2) * Math.Cos(goodLambda);

            //    a12 = atan2(numer, denom);

            double a12 = Math.Atan2(numer, denom);

            //    kidx = a12<0;

            kidx = a12 < 0;

            //    a12(kidx)=a12(kidx)+2*pi;

            if (kidx)
                a12 = a12 + 2 * Math.PI;

            //    % from poles:
            //    a12(lat1tr <= -90) = 0;

            if (lat1Tr <= -90.0)
                a12 = 0;

            //    a12(lat1tr >= 90 ) = pi;

            if (lat1Tr >= 90)
                a12 = Math.PI;

            //    varargout{2} = reshape(a12 * 57.2957795130823, keepsize); % to degrees

            // Convert to degrees
            return Azimuth.FromRadians(a12);

            //end
            //if nargout > 2
            //    a21=NaN*lat1;
            //    % From point #2 to point #1
            //    % correct sign of lambda for azimuth calcs:
            //    lambda = abs(lambda);
            //    kidx=sign(sin(lon1-lon2)) .* sign(sin(lambda)) < 0;
            //    lambda(kidx)=-lambda(kidx);
            //    numer = cos(U1).*sin(lambda);
            //    denom = sin(U1).*cos(U2)-cos(U1).*sin(U2).*cos(lambda);
            //    a21 = atan2(numer, denom);
            //    kidx=a21<0;
            //    a21(kidx)= a21(kidx)+2*pi;
            //    % backwards from poles:
            //    a21(lat2tr >= 90) = pi;
            //    a21(lat2tr <= -90) = 0;
            //    varargout{3} = reshape(a21 * 57.2957795130823, keepsize); % to degrees
            //end
            //return

            #endregion Newer code

            #region Unused Code (Commented Out)

            /*
            double lonrad = pLongitude.ToRadians().Value;
			double latrad = pLatitude.ToRadians().Value;
			double destlonrad = destination.Longitude.ToRadians().Value;
			double destlatrad = destination.Latitude.ToRadians().Value;

			double y = Math.Sin(lonrad - destlonrad) * Math.Cos(destlatrad);
			double x = Math.Cos(latrad) * Math.Sin(destlatrad)
				     - Math.Sin(latrad) * Math.Cos(destlatrad) * Math.Cos(lonrad - destlonrad);

			double rad = Math.Atan2(-y, x);
			return Azimuth.FromRadians(rad).Normalize();
             */

            //			try
            ////			{
            //				//Dim AdjustedDestination As Position = destination.ToEllipsoid(Ellipsoid.Type)
            //
            //				double y = -Math.Sin(Longitude.ToRadians().Value - destination.Longitude.ToRadians().Value)
            //					* Math.Cos(destination.Latitude.ToRadians().Value);
            //				double x = Math.Cos(Latitude.ToRadians().Value) * Math.Sin(destination.Latitude.ToRadians().Value)
            //					- Math.Sin(Latitude.ToRadians().Value) * Math.Cos(destination.Latitude.ToRadians().Value)
            //					* Math.Cos(Longitude.ToRadians().Value - destination.Longitude.ToRadians().Value);
            //
            //			//Console.WriteLine(String.Format("X: {0}, Y: {1}
            //
            ////			atan2(-sin(long1-long2).cos(lat2),
            ////cos(lat1).sin(lat2) - sin(lat1).cos(lat2).cos(long1-long2) )
            //
            //
            //				return new Azimuth(((Math.Atan2(y, x) * 180.0 / Math.PI) + 360) % 360); //+ 1 / 7200.0)
            //			}
            //			catch
            //			{
            //				throw new GpsException("Error while calculating initial bearing.");
            //			}
            // Test Data
            //
            // Name: Denver Oklahoma City
            // Latitude: 39 � 45 ' 0.00000 '' 35 � 26 ' 0.00000 ''
            // Longitude: 105 � 0 ' 0.00000 '' 97 � 28 ' 0.00000 ''
            // Forward Azimuth:  236 � 35 ' 21.15 ''
            // Reverse Azimuth:  51 � 59 ' 10.32 ''
            // Datumal Distance:  819373.914 meters

            //			'' Converted from JavaScript: http://www.movable-type.co.uk/scripts/LatLong.html
            //			''
            //			''	LatLong.bearing = function(p1, p2) {
            //			''  var y = Math.sin(p1.long-p2.long) * Math.cos(p2.lat);
            //			''  var x = Math.cos(p1.lat)*Math.sin(p2.lat) -
            //			''		  Math.sin(p1.lat)*Math.cos(p2.lat)*Math.cos(p1.long-p2.long);
            //			''  return (Math.atan2(-y, x)); // -y 'cos Williams treats W as +ve!
            //			'Try
            //			'	Dim AdjustedDestination As Position = destination				' destination.ToDatum(Datum.Type)

            //			'	Dim StartLatRad As Double = Latitude.ToRadians().Value
            //			'	Dim StartLonRad As Double = Longitude.ToRadians().Value
            //			'	Dim DestLatRad As Double = AdjustedDestination.Latitude.ToRadians().Value
            //			'	Dim DestLonRad As Double = AdjustedDestination.Longitude.ToRadians().Value

            //			'	Dim y As Double = -Math.Sin(StartLonRad - DestLonRad) * Math.Cos(DestLatRad)
            //			'	Dim x As Double = Math.Cos(StartLatRad) * Math.Sin(DestLatRad) _
            //			'		 - Math.Sin(StartLatRad) * Math.Cos(DestLatRad) * Math.Cos(StartLonRad - DestLonRad)
            //			'	Dim NewBearingRads As New Radian(Math.Atan2(y, x))
            //			'	'tc1=mod(atan2(sin(lon1-lon2)*cos(lat2),
            //			'	'		   cos(lat1)*sin(lat2)-sin(lat1)*cos(lat2)*cos(lon1-lon2)), 2*pi)

            //			'	Dim NewBearing As Double = (NewBearingRads.ToAngle.DecimalDegrees + 360) Mod 360				 '* 180.0 / Math.PI '+ 360) Mod 360 + 1 / 7200.0

            //			'	Return New Azimuth(NewBearing)				' Azimuth(double.Parse()
            //			'Catch ex As Exception
            //			'	Throw New GeoException("Error while calculating initial bearing.", ex)
            //			'End Try
            //			'' Test Data
            //			''
            //			'' Name: Denver Oklahoma City
            //			'' Latitude: 39 � 45 ' 0.00000 '' 35 � 26 ' 0.00000 ''
            //			'' Longitude: 105 � 0 ' 0.00000 '' 97 � 28 ' 0.00000 ''
            //			'' Forward Azimuth:  236 � 35 ' 21.15 ''
            //			'' Reverse Azimuth:  51 � 59 ' 10.32 ''
            //		   '' Datumal Distance:  819373.914 meters

            #endregion Unused Code (Commented Out)